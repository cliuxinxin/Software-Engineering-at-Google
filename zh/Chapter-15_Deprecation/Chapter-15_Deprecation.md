本章由海鲁姆·赖特撰写，由汤姆·曼什雷克编辑

我喜欢万事都有一个截止日期。 我喜欢它们飞过时发出的嗖嗖声。

所有系统都会老化。 虽说软件是一种数字资产,它的字节位本身不会有任何退化。但随着时间的推移，新技术、库、 技术、语言和其他环境变化,都有可能使现有的系统过时。 旧系统需要持续维护、深奥的专业知识，通常需要花费 更多的精力，因为它们与周遭的生态略有不同。 投入些精力废弃掉过时的系统通常是个不错的选项，让它们无限 期地与它的替代者共存通常不是明智的选择。 从实践的角度出发，那些仍在运行的大量过时系统无不表明，废弃 掉过时系统所带来的收益并非微不足道。 我们将有序迁移并最终移除过时系统的过程称为弃用。

与我们在本书中讨论的大多数章节不同，Google 仍在学习如何最好地“弃用”和删除软件系统。 本章主要介绍我们在 “弃用”大型和大量使用的内部系统时学到的经验教训。 有时，它能符合预期，有时则不会。毕竟移除过时系统的普 遍问题,仍然是行业中一个困难且须不断探索的问题。

本章主要从技术层面讲“弃用”，而不是从产品层面。 考虑到面向外部的 API 也算另一种产品，而内部 API 通常 是自产自销，因此这种区别有些武断。 尽管许多原则也适用于对外产品，但我们在这里关注的是“弃用”和删除过时 的内部系统的技术和策略方面的问题。

我们对“弃用”的讨论始于这样一个基本前提，即代码是一种负债，而不是一种资产。 毕竟，如果代码是一种资产， 我们为什么还要费心去尝试“弃用”它呢？ 代码有成本，其中有开发成本，但更多的是维护成本。 这些持续的成本， 例如保持系统运行所需的运营资源或紧跟周围生态而不断更新迭代花费的精力，意味着你需要在继续维护老化的系统运行和将其下线之间做一个权衡。

这两个系统可能需要相互连接，需要复杂的转换代码。 随着这两个系统的发展，它们可能会相互依赖，从而使最 终消除其中任何一个变得更加困难。 从长远来看，我们发现让多个系统执行相同的功能也会阻碍新系统的发展， 因为它仍然需要与旧的保持兼容性。 由于替换系统现在可以更快地发展，因此花费精力移除旧系统会有相关的收 益。

尽管“弃用”很有用，但我们在 Google 了解到，从执行“弃用”的团队以及这些团队的客户的角度来看，对同时进行的 ““弃用””是有数量上的限制的。 例如，虽然每个人都喜欢新铺设的道路，但如果政府部门决定同时关闭所有道路并 进行铺设，那么将会导致大家无路可走。 通过集中精力，铺设人员可以更快地完成特定工作，但同时不应该影响 其他道路的通行。 故同样重要的是要谨慎选择“弃用”项目并付诸实施。

我们在本书的其他地方提到了海拉姆定律，但值得在这里重申一下它的适用性：一个系统的用户越多，用户以意外 和不可预见的方式使用它的可能性就越大，并且越难“弃用”和删除这样的系统。 它们有可能只是“碰巧可用”而不是 “绝对可用”。 在这种情况下，“弃用”不是简单的行为变更，而是一次大变革-彻底的“弃用”！ 这种激进的改变可能会 对这样的系统造成意想不到的影响。

更复杂的是，在提供相同（或更好）功能的新系统可用之前，“弃用”通常不是一种选择。 新系统可能更好,但也有不 同：毕竟，如果它和过时的系统完全一样，它不会为迁移到它的用户提供任何好处（尽管它可能使运行它的团队 受益）。 这种功能差异意味着旧系统和新系统之间的一对一匹配很少见，新老系统的切换通常需要进行评估。

另一个令人惊讶的不愿“弃用”的现象是对旧系统的情感依恋，尤其是那些“弃用”者帮助创建的系统。 在 Google 系统 地删除旧代码时，就会发生这种厌恶更改的一个例子：我们偶尔会遇到“我喜欢这段代码！”这种形式的抵制。 说 服工程师删除他们花了多年时间建造的东西可能很困难。 这是一种可以理解的反应，但最终会弄巧成拙：如果一 个系统已经过时，它会给组织带来净成本，应该将其删除。 我们解决了将旧代码保留在 Google 中的问题的方法 之一是确保源代码存储库不仅可以在主干上搜索，而且可以在历史上搜索。 甚至被删除的代码也能再次找到 (见 17章)

最后，资助和执行“弃用”工作在政治上可能很困难； 为团队配备人员并花时间移除过时的系统会花费大量金钱，而 无所作为和让系统在无人看管的情况下缓慢运行的成本不易观察到。 很难让相关利益相关者相信“弃用”工作是值得 的，尤其是当它们对新功能开发产生负面影响时。 研究技术，例如第 7 章中描述的那些，可以提供具体的证据证 明“弃用”是值得的。

鉴于“弃用”和删除过时软件系统的难度，用户通常更容易就地改进系统，而不是完全替换它。 增量并没有完全避免 “弃用”过程，但它确实将其分解为更小、更易于管理的块，这些块可以产生增量收益。 在 Google 内部，我们观察 到迁移到全新系统的成本非常高，而且成本经常被低估。 增量“弃用”工作通过就地重构实现的功能可以保持现有系 统运行，同时更容易向用户交付价值。

与许多工程活动一样，软件系统的“弃用”可以在这些系统首次设计时便进行规划。 编程语言、软件架构、团队组成， 甚至公司策略和文化的选择都会影响系统在使用寿命结束后最终将其“弃用”的难易程度。

设计系统以使其最终可以被“弃用”的概念在软件工程中可能是激进的，但它在其他工程学科中很常见。 以核电站为 例，这是一项极其复杂的工程。 作为核电站设计的一部分，必须考虑到其在服务寿命到期后最终退役，甚至为此 分配资金。 当工程师知道它最终需要退役时，核电站建设中的许多设计,将会随之改变。

不幸的是，软件系统很少经过精心设计。 许多软件工程师更热心于构建和启动新系统，而不是维护现有系统。 包 括 Google 在内的许多公司的企业文化都强调快速构建和交付新产品，这通常会阻碍从一开始就考虑“弃用”的设计。 尽管普遍认为软件工程师是数据驱动的自动机，但在心理上很难为我们辛勤工作的创造物的最终消亡做计划。

那么，在设计我们将来更容易“弃用”的系统时，我们应该考虑哪些因素？ 以下是我们鼓励 Google 的工程团队提出的几个问题：

其中许多问题与系统如何提供和使用依赖项有关。 有关我们如何管理这些依赖项的更深入讨论，请参阅第 16 章。

最后，我们应该指出，是否长期支持项目的决定,是在组织最初决定建立项目时做出的。软件系统存在后，剩下的 唯一选择是支持它，小心地“弃用”它，或者在某些外部事件导致它崩溃时让它停止运行。这些都是有效的选项，它们 之间的权衡将是特定于组织的。当公司破产时，一个只有一个项目的新创业公司会毫不客气地杀死它，但一家大公 司在考虑删除旧项目时需要更仔细地考虑对其投资组合和声誉的影响。如前所述，谷歌仍在学习如何最好地利用我 们自己的内部和外部产品进行这些权衡。

简而言之，如果你的公司不打算长期支持某个项目，那么轻易不要启动这个项目。即使公司选择“弃用”项目，仍然会 有成本，但可以通过规划和投资工具和策略来降低成本。

建议性“弃用”是那些没有截止日期并且对组织来说不是高优先级的（并且公司不愿意为此投入资源）。这些也可能被标 记为理想“弃用”：团队知道系统已被替换，尽管他们希望客户最终迁移到新系统，但他们没有近期的计划来提供支持 以帮助客户迁移或删除旧系统。这种“弃用”往往缺乏执行力：我们希望客户迁移，但不强迫他们做。正如我们在 SRE 的朋友会很容易告诉你的那样：“希望不是策略。”

建议性“弃用”是宣传新系统存在并鼓励早期采用的用户开始尝试的好工具。这样的新系统不应该在测试阶段被考虑：它 应该准备好用于生产用途和负载，并且应该准备好无限期地支持新用户。当然，任何新系统都会经历成长的痛苦， 但是在旧系统以任何方式被“弃用”之后，新系统将成为组织基础设施的关键部分。

我们在谷歌看到的一种情况是，当新系统为其用户提供令人信服的好处时，建议性“弃用”具有强大的好处。 在这些情 况下，简单地通知用户这个新系统并为他们提供自助服务工具以迁移到它,通常会鼓励采用。然而，收益不能简单 地递增：它们必须具有变革性。否则用户将不愿为了这一点点边际收益而自行迁移，不过对于“建议性“弃用””，即 使具有巨大改进的新系统也通常不会被完全采纳。

建议性“弃用”允许系统作者将用户推向所需的方向，但不应指望他们完成大部分迁移工作。通常只需要在旧系统上简 单地发出“弃用”警告，然后弃之不顾即可。我们在 Google 的经验是，这可能会导致（略微）减少对过时系统的使用， 但很少会导致团队积极迁移。旧系统的现有功能会有一种吸引力，吸引更多的系统使用它,无论我们说多少，​​“请使 用新的系统。”除非更积极地鼓励其用户迁移，否则旧系统将需要继续维护。

这种“弃用”通常伴随着删除过时系统的最后期限：如果用户在该日期之后继续依赖它，他们将发现自己的系统不再正 常工作。

与直觉相反，推广强制性“弃用”工作的最佳方法是将迁移用户的工作交给一个专家团队——通常是负责完全删除旧系统 的团队。该团队有动力帮助其他人从过时的系统迁移，并可以开发可在整个组织中使用的经验和工具。许多这些迁 移可以使用第 22 章中讨论的相同工具来实现。

为了让强制性“弃用”真正起作用，需要有一个强制执行的时间表。并以警告的形式通知到需要执行迁移的客户团队。 没有这种能力，客户团队很容易忽略“弃用”工作，而转而支持其他更紧迫的工作。

同时，若没有安排人员协助，可能会给客户团队带来刻薄的印象，这通常会影响迁移的进度。 客户只是将它视为 一项没有资金的任务，要求他们搁置自己的优先事项，只为保持服务运行而迁移。 这会在两个团队间产生摩擦,故 此，我们建议安排人员进行协助迁移。

还值得注意的是，即使有策略支持，强制性“弃用”仍可能面临政治障碍。 想象一下，当旧系统的最后一个剩余用户 是整个组织所依赖的关键基础架构时， 你会愿意为了在截止日期前完成迁移而破坏那个基础设施及所有依赖它的 系统吗？ 如果该团队可以否决其进展，那它的强制性就值得怀疑。

在谷歌，当系统计划“弃用”时，团队经常会在关闭前的几个月和几周内宣布计划中断，持续时间会增加。与 Google 的灾难恢复测试 (DiRT) 类似，这些事件通常会发现正在运行的系统之间的未知依赖关系。这种渐进式方法允许那 些依赖的团队发现依赖，然后为系统的最终移除做计划，甚至与“弃用”团队合作调整他们的时间表。 （同样的原则 也适用于静态代码依赖，但静态分析工具提供的语义信息通常足以检测过时系统的所有依赖。）

对于建议性和强制“弃用”，以程序化的方式将系统标记为“弃用”通常很有用，这样用户就会及时的发现警告并远离它。 将某些东西标记为已“弃用”并希望它的使用最终消失通常很诱人，但请记住：“希望不是一种策略。” “弃用”警告可以 减少它的新增用户，但很少导致现有系统的迁移。

在实践中通常会发生这些警告随着时间的推移而累积。 如果它们在传递上下文中使用（例如，库 A 依赖于库 B， 而库 B 又依赖于库 C，而 C 发出警告，并在构建 A 时显示），则这些警告很快就会使系统用户不知所措 他们完 全忽略它们的点。 在医疗保健领域，这种现象被称为“警觉疲劳”。

向用户发出的任何“弃用”警告都需要具有两个属性：可操作性和相关性。 如果用户可以使用警告来实际执行某些相 关操作，则警告是可操作的，不仅在理论上，而且在实践中，即要提供可操作的迁移步骤，而不仅仅是一个警告。

警告可能是可行的，但仍然很烦人。 为了有用，“弃用”警告也应该是相关的。 如果警告在用户实际执行指示的操作 时出现，则该警告是相关的。 关于使用已“弃用”函数的警告最好在工程师编写使用该函数的代码时完成，而不是在 将其签入存储库数周后。 同样，最好在删除旧系统前几个月发送数据迁移电子邮件，而不是在删除前的一个周末 之后才发送。

警告不是越多越好。 警告本身并不坏，但不成熟的工具通常会产生大量警告消息，这些消息可能会让工程师不知 所措。 在 Google 内部，我们会将旧功能标记为已“弃用”，但会利用 ErrorProne 或 clang-tidy 等工具来确保以 有针对性的方式显示警告。 正如第 20 章中所讨论的，我们将这些警告限制在新更改的行中，以警告人们有关已 “弃用”符号的新用法。 更具侵入性的警告，例如依赖图中已“弃用”的警告，仅针对强制“弃用”添加，并且团队正在积极 地将用户移走。 在任何一种情况下，工具都在适当的时间向适当的人提供适当的信息方面发挥着重要作用，允许 添加更多警告而不会使用户感到疲倦。

我们在 Google 了解到，如果没有明确的Owner，无论系统产生了多少警报,“弃用”过程恐怕都不会太乐观。 为了弃 用专门指定一个负责人似乎是对资源的浪费，永不“弃用”，或将“弃用”工作完全交给系统的使用者,恐怕会是一个更糟 的方案。 交给使用者来执行的方案，最多只能应对建议性“弃用”，恐怕它很难做到彻底地“弃用”，而永不“弃用”则相当 于无限期地维护着旧系统。 集中性的执行“弃用”则更专业更透明，从而真正达到降低成本的目的。

废弃的项目通常会在确定归属权上存在扯皮的情形。 每个小组都存在大量仍在使用却无明确维护人的项目，谷歌 也不例外。 当一个项目存在这种情形时，通常说明它已被抛弃：即原维护人已参与到新项目开发维护中，老项目 则被弃之不顾，但却仍然被某些关键项目所依赖，只寄希望于它慢慢消失在众人视线中。

但此类项目不太可能自行消失。 尽管我们对之抱有最大的期寄，但我们发现,“弃用”这些项目仍然需要专人负责,否 则恐怕会造成意外的损失。 负责人应该将废弃他们作为主要目标。 在排优先级时，“弃用”通常会有较低的优先级, 且少有人关注。 但实际上，这些重要但不紧急的清理工作,占用掉程序员20%的工作时间,应该是个合适的数字。

在构建新系统时，项目里程碑通常非常明确：如“在下个季度推出某项功能。” 。 遵循迭代式开发流程的团队,通 常以积小成大的方式构建系统,并最终交付给用户，只要他们使用了新功能，他们的目的便算得到了。 最终目标当 然是启用整个系统，但增量迭代式的开发，则能让团队成员更有成就感，因他们无需等到项目结束就可体验项目。

相反，对于“弃用”，它常会给人一种只有一个里程碑的错觉，即完全干掉老旧的项目。 下班时，团队成员通常会有 没取得任何进展的感觉。 干掉一个老旧的项目对团队成员来说虽是颇有意义，但对团队之外的人来说却是完全无感， 因老旧的系统已不再被任何服务调用。 故项目经理不应将完全根除旧项目当作唯一的里程碑。

与新建项目一样，“弃用”一个项目也该渐进的设置多个可量化的里程碑,用于评估“弃用”进度的指标会有差异，但阶段 性的庆祝有助提升士气。

许多用于管理“弃用”过程的工具在本书的其他地方进行了深入讨论，例如大规模变更 (LSC) 过程（第 22 章）或我 们的代码审查工具（第 19 章）。 我们不讨论这些工具的细节，而是简要概述如何让这些工具在管理废弃系统的 “弃用”时发辉作用。 这些工具可以归类为发现、迁移和倒回滚预防工具。

在早期阶段，实际上在整个过程中，确认谁在使用及怎样使用我们的废弃项目很有必要。 初始工作通常是用于确 认谁在用、以及以怎样的方式使用。根据使用的方式不同，有可能会推翻我们“弃用”的推进流程。 我们还在整个弃 用过程中使用这些工具来了解工作进展情况。

在谷歌内部，我们使用代码搜索（见第 17 章）和 Kythe（见第 23 章）等工具来静态地确定哪些客户使用给定的 库，并经常对现有使用情况进行抽样，以了解客户的使用方式。 由于运行时依赖项通常需要使用一些静态库或瘦 客户端，因此该技术能提供大部分决策信息。 而生产中的日志记录和运行时采样有助于发现动态依赖项的问题。

最后，我们将集成测试套件视为预言机，以确定是否已删除对旧变量、函数的所有引用。 正如第 11 章所讨论的， 测试是一种防止系统随着生态系统发展而发生不必要的行为变化的机制。 “弃用”是这种演变的重要组成部分，客户 有责任进行足够的测试，以确保删除过时的系统不会对他们造成危害。

在 Google “弃用”的大部分工作是通过使用我们之前提到的同一组代码生成和审查工具来完成的,即LSC工具集。 它 在代码仓库在引入新库或运行时服务时会很有用。

最后，一个经常被忽视的问题是新增功能重新使用了废弃的项目。 即使对于建议性“弃用”，警告用户在编写新代码 时避免使用已“弃用”的系统而支持新系统也是很有用的。 如果没有后退预防机制，“弃用”可能会变成一场打地鼠游戏。 按下葫芦浮起瓢是很影响士气的。

为了防止使用废弃项目，我们使用 Tricorder 静态分析框架来通知用户他们正在调用一个“弃用”的系统中，并提供 替代方案。 废弃系统的维护者应该将不推荐使用的符号添加编译器注释（例如@deprecated Java 注释），并且 Tricorder 在审查时会将其发送给废弃项目的维护者。同时自动提醒调用者。 在某些情况下，该工具还能一键以 替代方案进行修复。

在宏观层面上，我们在构建系统中使用可见性白名单来确保不会将新的依赖项引入已“弃用”的系统。 自动化工具会 定期检查这些白名单，并在依赖系统从过时系统迁移时对其进行删剪。

完整的“弃用”过程涉及到管理和技术两个层面的挑战。 有效地管理“弃用”通常因不会带来盈利而被轻忽，但它对 其长期可持续性维护却至关重要。

